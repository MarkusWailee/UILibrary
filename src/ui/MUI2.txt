#include "MUI.hpp"
#include "Memory.hpp"


namespace UI
{
    struct Box
    {
        //container
        //Turned into pixel format
        Color background_color = UI::Color{0, 0, 0, 0};
        Color border_color = UI::Color{0, 0, 0, 0};

        //type 3
        uint16_t width =            0;
        uint16_t height =           0;
        uint16_t gap_row =          0;
        uint16_t gap_column =       0;
        uint16_t min_width =        0;
        uint16_t max_width =        0;
        uint16_t min_height =       0;
        uint16_t max_height =       0;
        int16_t x =                 0;
        int16_t y =                 0;
        uint16_t grid_cell_width =  0;
        uint16_t grid_cell_height = 0;

        Unit::Type width_unit =              Unit::Type::PIXEL;
        Unit::Type height_unit =             Unit::Type::PIXEL;
        Unit::Type gap_row_unit =            Unit::Type::PIXEL; //might not need
        Unit::Type gap_column_unit =         Unit::Type::PIXEL; //might not need
        Unit::Type min_width_unit =          Unit::Type::PIXEL;
        Unit::Type max_width_unit =          Unit::Type::PIXEL;
        Unit::Type min_height_unit =         Unit::Type::PIXEL;
        Unit::Type max_height_unit =         Unit::Type::PIXEL;
        Unit::Type x_unit =                  Unit::Type::PIXEL;
        Unit::Type y_unit =                  Unit::Type::PIXEL;
        Unit::Type grid_cell_width_unit =    Unit::Type::PIXEL;
        Unit::Type grid_cell_height_unit =   Unit::Type::PIXEL;

        uint8_t grid_row_max = 0;
        uint8_t grid_column_max = 0;
        uint8_t grid_row_start = 0;
        uint8_t grid_column_start = 0; 
        uint8_t grid_row_end = 0;
        uint8_t grid_column_end = 0; 

        Flow::Alignment flow_vertical_alignment = Flow::Alignment::START;
        Flow::Alignment flow_horizontal_alignment = Flow::Alignment::START;
        //PIXEL VALUES
        uint8_t corner_radius = 0; //255 sets to circle
        uint8_t border_width = 0;  
        Spacing padding;
        Spacing margin;
        Layout layout = Layout::FLOW;
    private:
        //Values that can potentially use bit array
        Positioning positioning = Positioning::RELATIVE;
        Flow::Axis flow_axis = Flow::Axis::VERTICAL;
        bool flow_wrap = false;
        bool scissor = false;
    public:
        void SetPositioning(Positioning p){positioning = p;}
        void SetFlowAxis(Flow::Axis axis){flow_axis = axis;}
        void SetScissor(bool flag){scissor = flag;}
        void SetFlowWrap(bool flag){flow_wrap = flag;}
        Layout GetLayout() const
        {
            return layout;
        }
        Flow::Axis GetFlowAxis() const
        {
            return flow_axis;
        }
        Positioning GetPositioning() const
        {
            return positioning;
        }
        bool IsScissor() const
        {
            return scissor;
        }
        bool IsFlowWrap() const
        {
            return flow_wrap;
        }

        float GetBoxModelWidth() const
        {
            //internal box model
            return (float)(margin.left + padding.left + width + padding.right + margin.right);
        }
        float GetBoxModelHeight() const
        {
            return (float)(margin.top + padding.top + height + padding.bottom + margin.bottom);
        }
        float GetRenderingWidth() const
        {
            return (float)(padding.left + width + padding.right);
        }
        float GetRenderingHeight() const
        {
            return (float)(padding.top + height + padding.bottom);
        }

    };

    template<typename T>
    struct TreeNode
    {
        T val;
        ArenaLL<TreeNode> children;
    };
}


//Common helpers and error handling
namespace UI
{
    struct Error
    {
        enum class Type : unsigned char
        {
            NO_ERROR,
            INCORRENT_UNIT_TYPE,
            NODE_CONFLICT,
            LEAF_NODE_CONFLICT,
            ROOT_NODE_CONFLICT,
            MISSING_END,
            MISSING_BEGIN
        };
        Type type = Type::NO_ERROR;
        char msg[96] = "\0";
        inline static int div_number = 0;
    };
    void DisplayError(const Error& error);
    Error CheckUnitErrors(const StyleSheet& style);
    Error CheckLeafNodeConflicts(const Box& leaf);
    Error CheckRootNodeConflicts(const StyleSheet& root);
    Error CheckNodeConflicts(const Box& child, const Box& parent);

    Error& GetGlobalError();
    bool HasGlobalError();

    //Returns false and does nothing if no error
    //Returns true, sets internal error, and displays error if true
    bool HandleGlobalError(const Error& error);

    //Math helpers
    float MillimeterToPixels(float mm);
    float CentimeterToPixels(float cm);
    float InchToPixels(float inches);
    template<typename T>
    T min(T a, T b);
    template<typename T>
    T max(T a, T b);
    float clamp(float minimum, float maximum, float value);



    //Used during tree descending
    Box ComputeStyleSheet(const StyleSheet& style, const Box& root);
    float MeasureLinearStack(ArenaLL<TreeNode<Box>>::Node* start_node, Flow::Axis axis, float gap_column, float gap_row);
    float MeasureLinearStack(ArenaLL<TreeNode<Box>>::Node* start_node, Flow::Axis axis, float max_width, float max_height, float gap_column, float gap_row);
}

//UI passes
namespace UI
{
    void AvailableAndParentPercentPass(TreeNode<Box>* node);
    void PositionPass(TreeNode<Box>* node);
    void DrawPass(TreeNode<Box>* node, float x, float y);
}


//GLOBALS
namespace UI
{
    StyleSheet default_style_sheet;

    float dpi = 96.0f;
    MemoryArena arena(8192);
    TreeNode<Box>* root_node = nullptr;
    FixedStack<TreeNode<Box>*, 100> stack; //elements should never nest over 100 layers deep
}

namespace UI
{
    void BeginBox(const UI::StyleSheet* style_sheet, const char* label, UI::MouseInfo* get_info)
    {
        if(HasGlobalError())
            return;
        Error::div_number++;
        StyleSheet style = style_sheet? *style_sheet: default_style_sheet;

        //Check for unit type errors
        //Could be moved into creating style sheets for more performance, but this is good enough for now
        if(HandleGlobalError(CheckUnitErrors(style)))
            return;

        if(stack.IsEmpty())//Root Node
        {
            //Checking errors unique to root node
            if(HandleGlobalError(CheckRootNodeConflicts(style)))
                return;
            root_node = arena.New<TreeNode<Box>>();
            assert(root_node && "Arena out of space");

            //compute 
            root_node->val = ComputeStyleSheet(style, Box());
            stack.Push(root_node);
        }
        else  // should add to parent
        {
            TreeNode<Box>* parent_node = stack.Peek();
            assert(parent_node);
            assert(root_node);

            TreeNode<Box> child_node;
            child_node.val = ComputeStyleSheet(style, root_node->val);
            TreeNode<Box>* child_ptr = parent_node->children.Add(child_node, &arena); 
            assert(child_ptr && "Arena out of memory");
            stack.Push(child_ptr);
        }
    }

    void EndBox()
    {
        if(HasGlobalError())
            return;
        if(stack.IsEmpty())
        {
            HandleGlobalError(Error{Error::Type::MISSING_BEGIN, "There are more EndBox() than BeginBox()"});
            return;
        }

        TreeNode<Box>* node = stack.Peek();
        assert(node);
        Box& node_box = node->val;
        if(node->children.IsEmpty())
        {
            if(HandleGlobalError(CheckLeafNodeConflicts(node_box)))
                return;
        }
        else 
        {

        }
         

        stack.Pop();

    }




    void Draw()
    {
        if(HasGlobalError())
            return;
        
        AvailableAndParentPercentPass(root_node);
        DrawPass(root_node, 0, 0);

        
        //Resetting everything
        arena.Reset(); 
        stack.Clear();
        root_node = nullptr;
        Error::div_number = 0;
    }

}




//Common helpers and error checking
namespace UI
{
    void DisplayError(const Error& error)
    {
        /*
        This is the only function that uses LogError_impl.
        I might change how logging works later, but this should suffice for now.
        Ideally I would like to create my own console using the ui and log info there.
        This function will stand as an imaginary implementation of this feature.
        For now it just logs into regular console which is implemented into MUI_raylib.cpp
        */
        switch(error.type)
        {
            case Error::Type::INCORRENT_UNIT_TYPE:
                LogError_impl("ERROR: incorrect unit type\n");
                break;
            case Error::Type::NODE_CONFLICT:
                LogError_impl("ERROR: node conflict\n");
                break;
            case Error::Type::LEAF_NODE_CONFLICT:
                LogError_impl("ERROR: leaf node confict\n");
                break;
            case Error::Type::ROOT_NODE_CONFLICT:
                LogError_impl("ERROR: root node conflict\n");
                break;
            case Error::Type::MISSING_END:
                LogError_impl("ERROR: missing End()\n");
                break;
            case Error::Type::MISSING_BEGIN:
                LogError_impl("ERROR: missing Begin()\n");
                break;
            default:
                return;
        }
        LogError_impl("Begin #");
        LogError_impl(error.div_number);
        LogError_impl("\n");

        LogError_impl("error.msg = '");
        LogError_impl(error.msg);
        LogError_impl("'");
    }


    #define UNIT_CONFLICT(value, unit_type, error_type)\
        if(value == unit_type) return Error{error_type, #value " = " #unit_type}

    Error CheckUnitErrors(const StyleSheet& style)
    {
        //The following units cannot equal the specified Unit Types 

        //Content%
        UNIT_CONFLICT(style.x.unit,                     Unit::Type::CONTENT_PERCENT, Error::Type::INCORRENT_UNIT_TYPE);
        UNIT_CONFLICT(style.y.unit,                     Unit::Type::CONTENT_PERCENT, Error::Type::INCORRENT_UNIT_TYPE);
        UNIT_CONFLICT(style.gap_row.unit,               Unit::Type::CONTENT_PERCENT, Error::Type::INCORRENT_UNIT_TYPE);
        UNIT_CONFLICT(style.gap_column.unit,            Unit::Type::CONTENT_PERCENT, Error::Type::INCORRENT_UNIT_TYPE);
        UNIT_CONFLICT(style.grid.cell_width.unit,       Unit::Type::CONTENT_PERCENT, Error::Type::INCORRENT_UNIT_TYPE);
        UNIT_CONFLICT(style.grid.cell_height.unit,      Unit::Type::CONTENT_PERCENT, Error::Type::INCORRENT_UNIT_TYPE);

        UNIT_CONFLICT(style.min_width.unit,             Unit::Type::CONTENT_PERCENT, Error::Type::INCORRENT_UNIT_TYPE);
        UNIT_CONFLICT(style.min_height.unit,            Unit::Type::CONTENT_PERCENT, Error::Type::INCORRENT_UNIT_TYPE);
        UNIT_CONFLICT(style.max_width.unit,             Unit::Type::CONTENT_PERCENT, Error::Type::INCORRENT_UNIT_TYPE);
        UNIT_CONFLICT(style.max_height.unit,            Unit::Type::CONTENT_PERCENT, Error::Type::INCORRENT_UNIT_TYPE);

        //Available%
        UNIT_CONFLICT(style.x.unit,                     Unit::Type::AVAILABLE_PERCENT, Error::Type::INCORRENT_UNIT_TYPE);
        UNIT_CONFLICT(style.y.unit,                     Unit::Type::AVAILABLE_PERCENT, Error::Type::INCORRENT_UNIT_TYPE);
        UNIT_CONFLICT(style.gap_row.unit,               Unit::Type::AVAILABLE_PERCENT, Error::Type::INCORRENT_UNIT_TYPE);
        UNIT_CONFLICT(style.gap_column.unit,            Unit::Type::AVAILABLE_PERCENT, Error::Type::INCORRENT_UNIT_TYPE);
        UNIT_CONFLICT(style.grid.cell_width.unit,       Unit::Type::AVAILABLE_PERCENT, Error::Type::INCORRENT_UNIT_TYPE);
        UNIT_CONFLICT(style.grid.cell_height.unit,      Unit::Type::AVAILABLE_PERCENT, Error::Type::INCORRENT_UNIT_TYPE);

        UNIT_CONFLICT(style.min_width.unit,             Unit::Type::AVAILABLE_PERCENT, Error::Type::INCORRENT_UNIT_TYPE);
        UNIT_CONFLICT(style.min_height.unit,            Unit::Type::AVAILABLE_PERCENT, Error::Type::INCORRENT_UNIT_TYPE);
        UNIT_CONFLICT(style.max_width.unit,             Unit::Type::AVAILABLE_PERCENT, Error::Type::INCORRENT_UNIT_TYPE);
        UNIT_CONFLICT(style.max_height.unit,            Unit::Type::AVAILABLE_PERCENT, Error::Type::INCORRENT_UNIT_TYPE);
        return Error();
    }



    Error CheckLeafNodeConflicts(const Box& leaf)
    {
        //The Following erros are contradictions
        if(leaf.width_unit == Unit::Type::CONTENT_PERCENT)
            return Error{Error::Type::LEAF_NODE_CONFLICT, "width.unit = Unit::Type::CONTENT_PERCENT with 0 children"};
        if(leaf.height_unit == Unit::Type::CONTENT_PERCENT)
            return Error{Error::Type::LEAF_NODE_CONFLICT, "height.unit = Unit::Type::CONTENT_PERCENT with 0 children"};
        return Error();
    }

    Error CheckRootNodeConflicts(const StyleSheet& root)
    {
        //Root node style sheet cannot equal any of these Unit types
        //The following errors are contradictions
        //Parent%
        UNIT_CONFLICT(root.width.unit,      Unit::Type::PARENT_PERCENT, Error::Type::ROOT_NODE_CONFLICT);
        UNIT_CONFLICT(root.height.unit,     Unit::Type::PARENT_PERCENT, Error::Type::ROOT_NODE_CONFLICT);
        UNIT_CONFLICT(root.min_width.unit,  Unit::Type::PARENT_PERCENT, Error::Type::ROOT_NODE_CONFLICT);
        UNIT_CONFLICT(root.min_height.unit, Unit::Type::PARENT_PERCENT, Error::Type::ROOT_NODE_CONFLICT);
        UNIT_CONFLICT(root.max_width.unit,  Unit::Type::PARENT_PERCENT, Error::Type::ROOT_NODE_CONFLICT);
        UNIT_CONFLICT(root.max_height.unit, Unit::Type::PARENT_PERCENT, Error::Type::ROOT_NODE_CONFLICT);
        UNIT_CONFLICT(root.x.unit,          Unit::Type::PARENT_PERCENT, Error::Type::ROOT_NODE_CONFLICT);
        UNIT_CONFLICT(root.y.unit,          Unit::Type::PARENT_PERCENT, Error::Type::ROOT_NODE_CONFLICT);
        UNIT_CONFLICT(root.gap_column.unit, Unit::Type::PARENT_PERCENT, Error::Type::ROOT_NODE_CONFLICT);
        UNIT_CONFLICT(root.gap_row.unit,    Unit::Type::PARENT_PERCENT, Error::Type::ROOT_NODE_CONFLICT);

        //Available%
        UNIT_CONFLICT(root.width.unit,      Unit::Type::AVAILABLE_PERCENT, Error::Type::ROOT_NODE_CONFLICT);
        UNIT_CONFLICT(root.height.unit,     Unit::Type::AVAILABLE_PERCENT, Error::Type::ROOT_NODE_CONFLICT);
        UNIT_CONFLICT(root.min_width.unit,  Unit::Type::AVAILABLE_PERCENT, Error::Type::ROOT_NODE_CONFLICT);
        UNIT_CONFLICT(root.min_height.unit, Unit::Type::AVAILABLE_PERCENT, Error::Type::ROOT_NODE_CONFLICT);
        UNIT_CONFLICT(root.max_width.unit,  Unit::Type::AVAILABLE_PERCENT, Error::Type::ROOT_NODE_CONFLICT);
        UNIT_CONFLICT(root.max_height.unit, Unit::Type::AVAILABLE_PERCENT, Error::Type::ROOT_NODE_CONFLICT);
        UNIT_CONFLICT(root.x.unit,          Unit::Type::AVAILABLE_PERCENT, Error::Type::ROOT_NODE_CONFLICT);
        UNIT_CONFLICT(root.y.unit,          Unit::Type::AVAILABLE_PERCENT, Error::Type::ROOT_NODE_CONFLICT);
        UNIT_CONFLICT(root.gap_column.unit, Unit::Type::AVAILABLE_PERCENT, Error::Type::ROOT_NODE_CONFLICT);
        UNIT_CONFLICT(root.gap_row.unit,    Unit::Type::AVAILABLE_PERCENT, Error::Type::ROOT_NODE_CONFLICT);

        //Root%
        UNIT_CONFLICT(root.width.unit,      Unit::Type::ROOT_PERCENT, Error::Type::ROOT_NODE_CONFLICT);
        UNIT_CONFLICT(root.height.unit,     Unit::Type::ROOT_PERCENT, Error::Type::ROOT_NODE_CONFLICT);
        UNIT_CONFLICT(root.min_width.unit,  Unit::Type::ROOT_PERCENT, Error::Type::ROOT_NODE_CONFLICT);
        UNIT_CONFLICT(root.min_height.unit, Unit::Type::ROOT_PERCENT, Error::Type::ROOT_NODE_CONFLICT);
        UNIT_CONFLICT(root.max_width.unit,  Unit::Type::ROOT_PERCENT, Error::Type::ROOT_NODE_CONFLICT);
        UNIT_CONFLICT(root.max_height.unit, Unit::Type::ROOT_PERCENT, Error::Type::ROOT_NODE_CONFLICT);
        UNIT_CONFLICT(root.x.unit,          Unit::Type::ROOT_PERCENT, Error::Type::ROOT_NODE_CONFLICT);
        UNIT_CONFLICT(root.y.unit,          Unit::Type::ROOT_PERCENT, Error::Type::ROOT_NODE_CONFLICT);
        UNIT_CONFLICT(root.gap_column.unit, Unit::Type::ROOT_PERCENT, Error::Type::ROOT_NODE_CONFLICT);
        UNIT_CONFLICT(root.gap_row.unit,    Unit::Type::ROOT_PERCENT, Error::Type::ROOT_NODE_CONFLICT);
        return Error();
    }
    Error CheckNodeConflicts(const Box& child, const Box& parent)
    {
        //The following errors are contradictions between parent and child

        //just checking with and height
        bool p_width = parent.width_unit == Unit::Type::CONTENT_PERCENT;
        bool p_height = parent.height_unit == Unit::Type::CONTENT_PERCENT;

        //width
        if(child.width_unit == Unit::Type::PARENT_PERCENT && p_width)
            return Error{Error::Type::NODE_CONFLICT, "width.unit = Unit::Type::PARENT_PERCENT && parent.width.unit = Unit::Type::CONTENT_PERCENT"};
        if(child.width_unit == Unit::Type::AVAILABLE_PERCENT && p_width) 
            return Error{Error::Type::NODE_CONFLICT, "width.unit = Unit::Type::AVAILABLE_PERCENT && parent.width.unit = Unit::Type::CONTENT_PERCENT"};

        //height
        if(child.height_unit == Unit::Type::PARENT_PERCENT && p_height)
            return Error{Error::Type::NODE_CONFLICT, "height.unit = Unit::Type::PARENT_PERCENT && parent.height.unit = Unit::Type::CONTENT_PERCENT"};
        if(child.height_unit == Unit::Type::AVAILABLE_PERCENT && p_height) 
            return Error{Error::Type::NODE_CONFLICT, "height.unit = Unit::Type::AVAILABLE_PERCENT && parent.height.unit = Unit::Type::CONTENT_PERCENT"};

        //no error
        return Error();
    }

    Error& GetGlobalError()
    {
        static Error internal_error;
        return internal_error;
    }
    bool HasGlobalError()
    {
        return GetGlobalError().type != Error::Type::NO_ERROR;
    }
    bool HandleGlobalError(const Error& error)
    {
        if(error.type != Error::Type::NO_ERROR)
        {
            GetGlobalError() = error;
            DisplayError(error);
            return true;
        }
        return false;
    }

    inline float MillimeterToPixels(float mm)
    {
        return mm * dpi / 25.4f;
    }
    inline float CentimeterToPixels(float cm)
    {
        return cm * dpi / 2.54f;
    }
    inline float InchToPixels(float inches)
    {
        return inches * dpi;
    }
    template<typename T>
    inline T min(T a, T b) {return a < b? a: b;}
    template<typename T>
    inline T max(T a, T b) {return a >= b? a: b;}
    template<typename T>
    inline T clamp(T minimum, T maximum, T value)
    {
        return max(min(value, maximum), minimum);
    }

    float DescendFixedUnitToPx(Unit unit, float root_pixels)
    {
        switch(unit.unit)
        {
            case Unit::Type::PIXEL:
                return (float)unit.value;
            case Unit::Type::MM:
                return MillimeterToPixels((float)unit.value);
            case Unit::Type::CM:
                return CentimeterToPixels((float)unit.value);
            case Unit::Type::ROOT_PERCENT: 
                return (float)unit.value / 100.0f * root_pixels;
            default:
                return unit.value; //Only meant for width/height
        }
    }
    Box ComputeStyleSheet(const StyleSheet& style, const Box& root)
    {
        float root_width = root.width - style.margin.left - style.margin.right - style.padding.left - style.padding.right;
        float root_height = root.height - style.margin.top - style.margin.bottom - style.padding.top - style.padding.bottom;
        Box box;
        box.background_color =  style.background_color;
        box.border_color =      style.border_color; 
        //units
        box.width =                 (uint16_t)max(0.0f, DescendFixedUnitToPx(style.width, root_width));
        box.height =                (uint16_t)max(0.0f, DescendFixedUnitToPx(style.height, root_height));
        box.gap_row =               (uint16_t)max(0.0f, DescendFixedUnitToPx(style.width, root_width));
        box.gap_column =            (uint16_t)max(0.0f, DescendFixedUnitToPx(style.height, root_height));
        box.min_width =             (uint16_t)max(0.0f, DescendFixedUnitToPx(style.width, root_width));
        box.max_width =             (uint16_t)max(0.0f, DescendFixedUnitToPx(style.width, root_width));
        box.min_height =            (uint16_t)max(0.0f, DescendFixedUnitToPx(style.height, root_height));
        box.max_height =            (uint16_t)max(0.0f, DescendFixedUnitToPx(style.height, root_height));
        box.x =                     (uint16_t)max(0.0f, DescendFixedUnitToPx(style.width, root_width));
        box.y =                     (uint16_t)max(0.0f, DescendFixedUnitToPx(style.height, root_height));
        box.grid_cell_width =       (uint16_t)max(0.0f, DescendFixedUnitToPx(style.width, root_width));
        box.grid_cell_height =      (uint16_t)max(0.0f, DescendFixedUnitToPx(style.height, root_height));
        //unit types
        box.width_unit =                style.width.unit;
        box.height_unit =               style.height.unit;
        box.gap_row_unit =              style.gap_row.unit; //might not need
        box.gap_column_unit =           style.gap_column.unit; //might not need
        box.min_width_unit =            style.min_width.unit;
        box.max_width_unit =            style.max_width.unit;
        box.min_height_unit =           style.min_height.unit;
        box.max_height_unit =           style.max_height.unit;
        box.x_unit =                    style.x.unit;
        box.y_unit =                    style.y.unit;
        box.grid_cell_width_unit =      style.grid.cell_width.unit;
        box.grid_cell_height_unit =     style.grid.cell_height.unit;
        //Pixel values
        box.grid_row_max =              style.grid.row_max;
        box.grid_column_max =           style.grid.column_max;
        box.grid_row_start =            style.grid.row_start;
        box.grid_column_start =         style.grid.column_start; 
        box.grid_row_end =              style.grid.row_end;
        box.grid_column_end =           style.grid.column_end; 
        box.flow_vertical_alignment =   style.flow.vertical_alignment;
        box.flow_horizontal_alignment = style.flow.horizontal_alignment;
        box.corner_radius =             style.corner_radius; //255 sets to circl
        box.border_width =              style.border_width;  
        box.padding =                   style.padding;
        box.margin =                    style.margin;
        box.layout =                    style.layout;

        box.SetPositioning(style.positioning);
        box.SetFlowAxis(style.flow.axis);
        box.SetScissor(style.scissor);
        box.SetFlowWrap(style.flow.wrap);

        return box;
    }



    inline float MeasureLinearStack(ArenaLL<TreeNode<Box>>::Node* start_node, Flow::Axis axis, float gap_column, float gap_row)
    {
        MeasureLinearStack(start_node, axis, 0, 0, gap_column, gap_row);
    }
    inline float MeasureLinearStack(ArenaLL<TreeNode<Box>>::Node* start_node, Flow::Axis axis, float max_width, float max_height, float gap_column, float gap_row)
    {
        assert(start_node);
        float distance = 0;
        if(axis == Flow::Axis::HORIZONTAL)
        {
            while(start_node!=nullptr)
            {
                const Box& box = start_node->value.val;
                float new_distance = distance + box.GetBoxModelWidth() + gap_column;
                if(max_width > 0 && new_distance >= max_width)
                    return distance;
                distance = new_distance;
                start_node = start_node->next;
            }
        }
        else
        {
            while(start_node!=nullptr)
            {
                const Box& box = start_node->value.val;
                float new_distance = distance + box.GetBoxModelHeight() + gap_column;
                if(max_height > 0 && new_distance >= max_height)
                    return distance;
                distance = new_distance;
                start_node = start_node->next;
            }
        }
        return distance;
    }
    //void MeasureContent(float* total_width, float* total_height, float)
}




//AVAILABLE PERCENT PASSS
namespace UI
{
    void TraverseAvailableAndParentPercent(ArenaLL<TreeNode<Box>>::Node* start_node, Flow::Axis axis, float parent_width, float parent_height);
    void AvailableAndParentPercentPass(TreeNode<Box>* node)
    {
        if(node == nullptr || node->children.IsEmpty()) 
            return;
        ArenaLL<TreeNode<Box>>::Node* child_node = node->children.GetHead();
        const Box& box = node->val;
        if(box.layout == Layout::FLOW)
        {
            TraverseAvailableAndParentPercent(child_node, box.GetFlowAxis(), box.width, box.height);
        }
        else //Grid
        {

        }
    }

    float DescendParentPercentUnitToPx(float unit_value, Unit::Type unit_type, float parent_pixels);
    void ComputeParentPercentForBox(Box& box, float parent_width, float parent_height);
    void TraverseAvailableAndParentPercent(ArenaLL<TreeNode<Box>>::Node* start_node, Flow::Axis axis, float parent_width, float parent_height)
    {
        assert(start_node);
        ArenaLL<TreeNode<Box>>::Node* temp = start_node;
        if(axis == Flow::Axis::HORIZONTAL)
        {
            float total_percent = 0;
            float available_width = parent_width;
            while(temp != nullptr)
            {
                Box& box = temp->value.val;
                if(box.width_unit == Unit::Type::AVAILABLE_PERCENT)
                {
                    total_percent += box.width;
                    available_width -= box.padding.left + box.padding.right + box.margin.left + box.margin.right;
                }
                else 
                {
                    ComputeParentPercentForBox(box, parent_width, parent_height);
                    available_width -= box.GetBoxModelWidth();
                }
                temp = temp->next;
            }

            temp = start_node;
            while(temp != nullptr)
            {
                Box& box = temp->value.val;
                if(box.width_unit == Unit::Type::AVAILABLE_PERCENT)
                    box.width = available_width * box.width / total_percent;
                AvailableAndParentPercentPass(&temp->value);
                temp = temp->next;
            }
        }
        else
        {

        }
    }
    float DescendParentPercentUnitToPx(float unit_value, Unit::Type unit_type, float parent_pixels)
    {
        return unit_type == Unit::Type::PARENT_PERCENT? parent_pixels * unit_value / 100.f: unit_value;
    }
    void ComputeParentPercentForBox(Box& box, float parent_width, float parent_height)
    {
        box.width =             (uint16_t)max(0.0f, DescendParentPercentUnitToPx(box.width,             box.width_unit,             parent_width));
        box.height =            (uint16_t)max(0.0f, DescendParentPercentUnitToPx(box.height,            box.height_unit,            parent_height));
        box.gap_row =           (uint16_t)max(0.0f, DescendParentPercentUnitToPx(box.gap_row,           box.gap_row_unit,           parent_height));
        box.gap_column =        (uint16_t)max(0.0f, DescendParentPercentUnitToPx(box.gap_column,        box.gap_column_unit,        parent_height));
        box.min_width =         (uint16_t)max(0.0f, DescendParentPercentUnitToPx(box.min_width,         box.min_width_unit,         parent_width));
        box.max_width =         (uint16_t)max(0.0f, DescendParentPercentUnitToPx(box.max_width,         box.max_width_unit,         parent_width));
        box.min_height =        (uint16_t)max(0.0f, DescendParentPercentUnitToPx(box.min_height,        box.min_height_unit,        parent_height));
        box.max_height =        (uint16_t)max(0.0f, DescendParentPercentUnitToPx(box.max_height,        box.max_height_unit,        parent_height));
        box.x =                 (int16_t)DescendParentPercentUnitToPx(box.x,                 box.x_unit,                 parent_width);
        box.y =                 (int16_t)DescendParentPercentUnitToPx(box.y,                 box.y_unit,                 parent_height);
        box.grid_cell_width =   (uint16_t)max(0.0f, DescendParentPercentUnitToPx(box.grid_cell_width,   box.grid_cell_width_unit,   parent_width));
        box.grid_cell_height =  (uint16_t)max(0.0f, DescendParentPercentUnitToPx(box.grid_cell_height,  box.grid_cell_height_unit,  parent_height));
    }
}



//DRAW PASSS
namespace UI
{





    void DrawLayout_FlowHorizontal_h(TreeNode<Box>* node, float x, float y);
    void DrawPass(TreeNode<Box>* node, float x, float y)
    {
        if(node == nullptr || node->children.IsEmpty())
            return;
        const Box& box = node->val;
        if(box.GetLayout() == Layout::FLOW)
        {
            if(box.GetFlowAxis() == Flow::Axis::HORIZONTAL)
                DrawLayout_FlowHorizontal_h(node, x, y);
        }
    }
    void DrawLayout_FlowHorizontal_h(TreeNode<Box>* node, float x, float y)
    {
        //No wrapping
        ArenaLL<TreeNode<Box>>::Node* head = node->children.GetHead();
        assert(head);
        const Box& parent_box = node->val;
        float cursor_x = 0;
        float cursor_y = 0;
        float largest_height = 0;
        while(head!=nullptr) 
        {
            //Draw parameters
            const Box& box = head->value.val;
            float render_width =    box.GetRenderingWidth();
            float render_height =   box.GetRenderingHeight();
            float render_x =        x + (float)(cursor_x + box.margin.left + parent_box.padding.left);
            float render_y =        y + (float)(cursor_y + box.margin.top + parent_box.padding.top);
            float corner_radius =   box.corner_radius;
            float border_size =     box.border_width;
            Color border_c =        box.border_color;
            Color bg_c =            box.background_color;
            DrawRectangle_impl(render_x, render_y, render_width, render_height, corner_radius, border_size, border_c, bg_c);

            DrawPass(&head->value, render_x, render_y);
            head = head->next;
            float linear_stack_x = box.GetBoxModelWidth() + (float)parent_box.gap_column;
            float linear_stack_y = box.GetBoxModelHeight() + (float)parent_box.gap_row;
            float increment_x;
            float increment_y;
            cursor_x+=linear_stack_x;

            //if(cursor_x >= parent_box.width) // avoid rendering anything outside of its parent
            //    return;
        }
    }
}